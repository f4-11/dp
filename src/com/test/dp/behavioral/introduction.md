- observer 观察者/发布订阅模式 一对多的关系 同步阻塞/异步非阻塞
  - subject/observer
  - publisher/subscriber
  - producer/consumer
  - eventemitter/eventlistener
  - dispatcher/listener 这里使用事件总线eventbus可以写的简单，事件总线实现比较复杂，可以看书
-
- mediator 复杂网状关系转为一对多星形关系，有可能变为大而复杂的上帝类
- interpreter 解释器/编译器/规则引擎
- command 包装函数，根据参数不同执行不同命令，排队执行，记录日志，撤销...
- template 用于代码复用/拓展框架 某些地方留白交给子类机型实现 类似的，某些地方可以传入回调接口实现回调函数来实现模板模式的作用(hook), 模板是继承，回调是组合，更灵活
- memento 备忘录/快照模式，进行备份和恢复
- strategy 拓展框架，查表切换函数/算法，避免冗长的ifelse/switch判断
- chainofresponsibility 拓展框架，a->b->c...进行依次的处理，使用链表/数组存储处理器，方案有依次全部运行一遍(敏感词打马赛克)/依次遍历直到被处理为止(敏感词禁止发布),可以开发过滤器/拦截器
- state 状态机--游戏(状态太多不好维护，推荐查表法)/工作引擎(如电商事件触发 状态模式)--状态模式(为状态接口的每一种状态都实现了一个类，适用于状态不多且动作复杂的)/分支逻辑(逻辑简单)/查表(动作简单) 状态可以用枚举来表示
- iterator 迭代器模式/游标模式 用于遍历集合对象/容器/聚合对象--数组/链表/树/图/跳表...,包含容器+容器迭代器
- visitor 将一个或多个操作应用到一组继承同一父类的不同类型对象上 使用多态实现不好维护，比如添加功能 使用访问者模式我的理解是把逻辑进行了集中，便于修改 但是难理解，难实现，非必要不使用
  - java 只支持单委派 visitor实现了double dispatch 也可以使用工厂模式